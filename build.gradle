// Reference https://www.jetbrains.org/intellij/sdk/docs/tutorials/build_system/gradle_guide.html
import org.apache.tools.ant.taskdefs.condition.Os

plugins {
    id 'java'
    id 'org.jetbrains.kotlin.jvm' version '1.9.24'
    id 'org.jetbrains.intellij.platform' version '2.1.0'

    id 'com.jetbrains.rdgen' version '2024.3.0'    // https://www.myget.org/feed/rd-snapshots/package/maven/com.jetbrains.rd/rd-gen
}

ext {
    isWindows = Os.isFamily(Os.FAMILY_WINDOWS)
    rdLibDirectory = {
        intellijPlatform.platformPath.resolve("lib").toFile()
    }
}

repositories {
    mavenCentral()
    intellijPlatform {
        localPlatformArtifacts()
        defaultRepositories()
        jetbrainsRuntime()
        intellijDependencies()
    }
    maven { url 'https://cache-redirector.jetbrains.com/intellij-repository/snapshots' }
    maven { url 'https://cache-redirector.jetbrains.com/maven-central' }
}

wrapper {
    gradleVersion = '8.8'
    distributionType = Wrapper.DistributionType.ALL
    distributionUrl = "https://cache-redirector.jetbrains.com/services.gradle.org/distributions/gradle-${gradleVersion}-all.zip"
}

version = ext.PluginVersion

dependencies {
    intellijPlatform {
        rider(ProductVersion)
        instrumentationTools()

        bundledPlugin "com.intellij.resharper.unity"

    }
}

configurations {
    riderModel {
        canBeConsumed = true
        canBeResolved = false
    }
}

sourceSets {
    main {
        java.srcDir 'src/rider/main/java'
        kotlin.srcDir 'src/rider/main/kotlin'
        resources.srcDir 'src/rider/main/resources'
    }
}

intellijPlatform {
    autoReload = false
}

compileKotlin {
    kotlinOptions { jvmTarget = "17" }
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

task setBuildTool {
    doLast {
        ext.executable = "dotnet"
        ext.args = ["msbuild"]

        if (isWindows) {
            ByteArrayOutputStream stdout = new ByteArrayOutputStream()
            exec {
                executable "${rootDir}\\tools\\vswhere.exe"
                args '-latest','-property','installationPath','-products','*'
                standardOutput = stdout
                workingDir rootDir
            }

            def directory = "C:\\Program Files\\dotnet"
            if (directory) {
                List<String> files = new FileNameFinder().getFileNames("${directory}", "**/dotnet.exe")
                ext.executable = files.get(0)
                ext.args = ["/v:minimal"]
            }
        }

        ext.args << "${DotnetSolution}"
        ext.args << "/p:Configuration=${BuildConfiguration}"
        ext.args << "/p:HostFullIdentifier="
    }
}

task compileDotNet {
    dependsOn setBuildTool
    doLast {
        def arguments = setBuildTool.args.clone()
        arguments << "/t:Restore;Rebuild"
        exec {
            executable setBuildTool.executable
            args arguments
            workingDir rootDir
        }
    }
}


buildPlugin {
    doLast {
        copy {
            from "${buildDir}/distributions/${rootProject.name}-${version}.zip"
            into "${rootDir}/output"
        }

        // TODO: See also org.jetbrains.changelog: https://github.com/JetBrains/gradle-changelog-plugin
        def changelogText = file("${rootDir}/CHANGELOG.md").text
        def changelogMatches = changelogText =~ /(?s)(-.+?)(?=##|$)/
        def changeNotes = changelogMatches.collect {
            it[1].replaceAll(/(?s)- /, "\u2022 ").replaceAll(/`/, "").replaceAll(/,/, "%2C").replaceAll(/;/, "%3B")
        }.take(1).join("")

//        def arguments = setBuildTool.args.clone()
//        arguments << "/t:Pack"
//        arguments << "/p:PackageOutputPath=${rootDir}/output"
//        arguments << "/p:PackageReleaseNotes=${changeNotes}"
//        arguments << "/p:PackageVersion=${version}"
//        exec {
//            executable setBuildTool.executable
//            args arguments
//            workingDir rootDir
//        }
    }
}

runIde {
    // Match Rider's default heap size of 1.5Gb (default for runIde is 512Mb)
    maxHeapSize = "1500m"
}

rdgen {
    def modelDir = new File(rootDir, "protocol/src/main/kotlin/model")
    def csOutput = new File(rootDir, "src/dotnet/${DotnetPluginId}/Rider")
    def ktOutput = new File(rootDir, "src/rider/main/kotlin/")

    verbose = true
    classpath {
        "${rdLibDirectory()}/rd.jar"
    }
    sources "${modelDir}/rider"
    hashFolder = "${buildDir}"
    packages = "model.rider"
    println(intellijPlatform.platformPath.resolve("lib/rd/rider-model.jar"))

    generator {
        language = "kotlin"
        transform = "asis"
        root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
        namespace = "com.jetbrains.rider.model"
        directory = "$ktOutput"
    }

    generator {
        language = "csharp"
        transform = "reversed"
        root = "com.jetbrains.rider.model.nova.ide.IdeRoot"
        namespace = "JetBrains.Rider.Model"
        directory = "$csOutput"
    }
}

prepareSandbox {
    dependsOn compileDotNet

    def outputFolder = "${rootDir}/src/dotnet/${DotnetPluginId}/bin/${DotnetPluginId}.Rider/${BuildConfiguration}"
    def dllFiles = [
            "$outputFolder/${DotnetPluginId}.dll",
            "$outputFolder/${DotnetPluginId}.pdb",
            // TODO: add additional assemblies
    ]

    dllFiles.forEach({ f ->
        def file = file(f)
        from(file, { into "${rootProject.name}/dotnet" })
    })

    from("${rootDir}/src/dotnet/${DotnetPluginId}/projectTemplates", { into "${rootProject.name}/projectTemplates"})

    doLast {
        dllFiles.forEach({ f ->
            def file = file(f)
            if (!file.exists()) throw new RuntimeException("File ${file} does not exist")
        })
    }
}

publishPlugin {
    dependsOn buildPlugin
    token = "${PublishToken}"

    doLast {
        exec {
            executable "dotnet"
            args "nuget","push","output/${DotnetPluginId}.${version}.nupkg","--api-key","${PublishToken}","--source","https://plugins.jetbrains.com"
            workingDir rootDir
        }
    }
}

tasks {
    patchPluginXml {
        untilBuild.set(provider { null })
    }
}